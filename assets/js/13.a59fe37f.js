(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{327:function(e,t,o){"use strict";o.r(t);var s=o(33),v=Object(s.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"与react-hooks的比较"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#与react-hooks的比较"}},[e._v("#")]),e._v(" 与React Hooks的比较")]),e._v(" "),o("p",[e._v("基于函数的API提供了与React Hooks相同级别的逻辑组合功能，但有一些重要的区别。与React钩子不同， "),o("code",[e._v("setup()")]),e._v(" 函数仅被调用一次。这意味着使用Vue的Composition API的代码为：")]),e._v(" "),o("ul",[o("li",[e._v("总的来说，它更符合惯用的JavaScript代码的直觉；")]),e._v(" "),o("li",[e._v("对呼叫顺序不敏感，可以有条件；")]),e._v(" "),o("li",[e._v("每次提炼不重复调用，产生的GC压力较小；")]),e._v(" "),o("li",[e._v("不必考虑几乎总是需要 "),o("code",[e._v("useCallback")]),e._v(" 的问题，以防止内联处理程序导致子组件的过度重新渲染；")]),e._v(" "),o("li",[e._v("如果用户忘记传递正确的依赖项数组，"),o("code",[e._v("useEffect")]),e._v(" 和 "),o("code",[e._v("useMemo")]),e._v(" 可能会捕获过时的变量，这不受此问题的影响。Vue的自动依赖关系跟踪确保观察者和计算值始终正确无效。")])]),e._v(" "),o("p",[e._v("我们认可React Hooks的创造力，这是该建议的主要灵感来源。但是，上面提到的问题确实存在于设计中，我们注意到Vue的反应性模型提供了解决这些问题的方法。")])])}),[],!1,null,null,null);t.default=v.exports}}]);