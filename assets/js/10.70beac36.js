(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{333:function(t,e,r){"use strict";r.r(e);var s=r(33),p=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"更好的类型推断"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#更好的类型推断"}},[t._v("#")]),t._v(" 更好的类型推断")]),t._v(" "),r("p",[t._v("开发人员在大型项目上的另一个常见功能要求是更好的TypeScript支持。\nVue当前的API在与TypeScript集成时提出了一些挑战，这主要是因为Vue仅依靠一个 "),r("code",[t._v("this")]),t._v(" 上下文来公开属性，并且在Vue组件中使用 "),r("code",[t._v("this")]),t._v(" 比普通JavaScript更具魔力。\n（例如，嵌套在方法下的内部函数 "),r("code",[t._v("this")]),t._v(" 指向组件实例，而不是方法对象）。\n换句话说，Vue现有的API在设计时就没有考虑类型推断，所以在尝试使其与TypeScript完美配合时会产生很多复杂性。")]),t._v(" "),r("p",[t._v("今天，大多数将Vue与TypeScript一起使用的用户正在使用 "),r("code",[t._v("vue-class-component")]),t._v("，这是一个库，可将组件编写为TypeScript类（在装饰器的帮助下）。在设计3.0时，我们尝试提供一个内置的Class API，以更好地解决 "),r("a",{attrs:{href:"https://github.com/vuejs/rfcs/pull/17",target:"_blank",rel:"noopener noreferrer"}},[t._v("先前（已删除）RFC"),r("OutboundLink")],1),t._v(" 中的键入问题。但是，当我们在设计上进行讨论和迭代时，我们注意到，要使Class API解决类型问题，它必须依赖装饰器-这是一个非常不稳定的第2阶段提案，在实现细节方面存在很多不确定性。这使其成为一个相当危险的基础。（有关类API类型问题的更多详细信息，请点击 "),r("RouterLink",{attrs:{to:"/type-issues-with-class-api/"}},[t._v("此处")]),t._v("）")],1),t._v(" "),r("p",[t._v("相比之下，此RFC中提议的API大多使用普通的变量和函数，它们自然是类型友好的。用建议的API编写的代码可以享受完整的类型推断，几乎不需要手动类型提示。这也意味着用提议的API编写的代码在TypeScript和普通JavaScript中看起来几乎相同，因此，即使非TypeScript用户也可以从键入中受益，以获得更好的IDE支持。")])])}),[],!1,null,null,null);e.default=p.exports}}]);