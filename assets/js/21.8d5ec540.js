(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{341:function(e,t,v){"use strict";v.r(t);var _=v(33),l=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"介绍引用的开销"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#介绍引用的开销"}},[e._v("#")]),e._v(" 介绍引用的开销")]),e._v(" "),v("p",[e._v("从技术上讲，Ref是此提案中引入的唯一“新”概念。引入它是为了将响应值作为变量传递，而不依赖于 "),v("code",[e._v("this")]),e._v(" 的访问。缺点是：")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("使用Composition API时，我们将需要不断将ref与纯值和对象区分开来，从而增加了使用API​​时的精神负担。")]),e._v(" "),v("p",[e._v("通过使用命名约定（例如，将所有ref变量后缀为 "),v("code",[e._v("xxxRef")]),e._v("）或使用类型系统，可以大大减轻心理负担。另一方面，由于提高了代码组织的灵活性，因此组件逻辑将更多地被隔离为一些小的函数，这些函数的局部上下文很简单，引用的开销很容易管理。")])]),e._v(" "),v("li",[v("p",[e._v("由于需要 "),v("code",[e._v(".value")]),e._v("，因此读取和修改ref比使用普通值更冗长。")]),e._v(" "),v("p",[e._v("一些人建议使用编译时语法糖（类似于Svelte 3）来解决此问题。尽管从技术上讲这是可行的，但我们认为将其作为Vue的默认值是没有道理的（如在 "),v("RouterLink",{attrs:{to:"/comparison-with-svelte/"}},[e._v("与Svelte的比较")]),e._v(" 中所讨论的）。就是说，这在用户领域作为Babel插件在技术上是可行的。")],1)])]),e._v(" "),v("p",[e._v("我们已经讨论了是否有可能完全避免使用Ref概念并仅使用反应性对象，但是：")]),e._v(" "),v("ul",[v("li",[e._v("计算的获取器可以返回原始类型，因此不可避免地要使用类似Ref的容器。")]),e._v(" "),v("li",[e._v("仅出于反应性的考虑，仅期望或返回原始类型的组合函数也需要将值包装在对象中。如果框架没有提供标准的实现，那么用户很有可能最终会发明自己的Ref like模式（并导致生态系统碎片化）。")])])])}),[],!1,null,null,null);t.default=l.exports}}]);