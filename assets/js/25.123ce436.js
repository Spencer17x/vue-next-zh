(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{342:function(s,t,a){"use strict";a.r(t);var e=a(33),p=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"类api的类型问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类api的类型问题"}},[s._v("#")]),s._v(" 类API的类型问题")]),s._v(" "),a("p",[s._v("引入类API的主要目的是提供一种具有更好TypeScript推理支持的替代API。但是，Vue组件需要将从多个源声明的属性合并到一个单独的 "),a("code",[s._v("this")]),s._v(" 上下文中，即使使用基于Class的API也会带来一些挑战。")]),s._v(" "),a("p",[s._v("一个例子是 props。为了合并 props 到 "),a("code",[s._v("this")]),s._v("，我们必须对组件类使用通用参数，或者使用装饰器。")]),s._v(" "),a("p",[s._v("这是使用通用参数的示例：")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("interface")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Props")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  message"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" string\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("App")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extends")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Component")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("Props"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" props "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    message"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" String\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),a("p",[s._v("由于传递给泛型参数的接口仅处于类型区域，因此用户仍需要为此提供的props代理行为提供运行时props声明在 "),a("code",[s._v("this")]),s._v("。该双重声明是多余且笨拙的。")]),s._v(" "),a("p",[s._v("我们已经考虑过使用装饰器作为替代：")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("class")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("App")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extends")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Component")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("Props"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  @prop message"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" string\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),a("p",[s._v("使用装饰器会产生对第二阶段规范的依赖，存在很多不确定性，尤其是当TypeScript的当前实现与TC39提案完全不同步时。此外，无法在 "),a("code",[s._v("this.$props")]),s._v(" 上公开用装饰器声明的 props 类型，这会破坏TSX的支持。用户还可以假设他们可以通过 "),a("code",[s._v("@prop message: string = 'foo'")]),s._v(" 声明prop的默认值，从技术上讲，它不能按预期工作。")]),s._v(" "),a("p",[s._v("另外，当前没有办法利用上下文类型作为类方法的参数-这意味着传递给Class的 "),a("code",[s._v("render")]),s._v(" 函数的参数不能基于Class的其他属性来推断类型。")])])}),[],!1,null,null,null);t.default=p.exports}}]);